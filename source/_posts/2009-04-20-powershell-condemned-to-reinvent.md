---
layout: post
title: "PowerShell: condemned to reinvent"
date: 2009-04-20
comments: false
---

<div class='blogger'>
  <div class='post'>
    <p>I tried PowerShell when it was first released, but never used it for real work. I recently attended a &quot;brown bag&quot; presentation about PowerShell. This presentation spurred me to augment our team's environment with PowerShell and I have been using it every day since.</p>  <p>In the past weeks using and abusing PowerShell, I have drawn two conclusions:</p>  <ol>   <li>PowerShell has a killer set of standard tools with brilliantly designed usability.</li>    <li>The PowerShell team doesn't understand UNIX and therefore were condemned to reinvented it, poorly -- with apologies to Henry Spencer.</li> </ol>  <p>First things first: if you spend any time working with Windows, get PowerShell. Now. Stop reading my blog and go <a href="http://www.microsoft.com/windowsserver2003/technologies/management/powershell/download.mspx">download it</a> immediately. It mops the floor with cmd.</p>  <p>The key premise behind PowerShell is that it operates on live .NET objects. This is beneficial because it eliminates a lot of the text cutting and manipulation common in shell scripts. Additionally, it puts the full .NET Base Class Library into your scripting toolbox. PowerShell tools, known as commandlets, typically only render the most common fields for their objects, but the less common fields are easily available in memory. By convention, Commandlets are named with a <em>verb</em>-<em>noun</em> pattern and support a common command line parsing behavior. The repository of commandlets and the command line options of each are easily queried and highly consistent. All this meta-data makes PowerShell a breeze to learn.</p>  <p>I fell in love with the the discoverablity and ease of use when I tried to kill a collection of runaway processes:</p>  <pre class="code">PS&gt; get-command -noun process<br /><br />CommandType   Name           Definition<br />-----------   ----           ----------<br />Cmdlet        Get-Process    Get-Process [[-Name] &lt;String[]&gt;] [-Verbo...<br />Cmdlet        Stop-Process   Stop-Process [-Id] &lt;Int32[]&gt; [-PassThru]...<br /><br />PS&gt; get-process notepad | stop-process<br />PS&gt; get-alias | where { $_.definition.contains(&quot;Process&quot;) }<br /><br />CommandType   Name   Definition<br />-----------   ----   ----------<br />Alias         kill   Stop-Process<br />Alias         ps     Get-Process<br /><br />PS&gt; ps someotherapp | kill<br /></pre><p>OK, that's pretty cool and oh-so-very Unixy -- right? Wrong. Notice the &quot;CommandType&quot; column in the results of get-command. There are many other types of commands besides commandlets: functions, filters, scripts, applications, etc. Each of these has slightly different semantics for pipes and parameters. Applications, for example, have no way of accepting .NET object pipes. You must develop a separate commandlet. Yikes!</p><p>Compare to Unix: all commands are applications which accept a command line and pipe byte streams in and out. Much simpler, but byte streams aren't as friendly, discoverable, and maintainable as object streams. However, the brilliantly simple thing about Unix is that, when you get right down to it, object streams are just byte streams! There is absolutely nothing stopping you from implementing <em>get-process</em> and <em>stop-process</em> as Unix programs which pipe object references, JSON, pickled Python objects, XML, S-expressions, or any other data format you fancy. Doug Mcllroy, the inventor of Unix pipes, was right: text streams are the universal interface.</p><p>Actually, this is no different on Windows. All of the PowerShell commandlets could have been implemented as applications which import a library. This library would replace <em>main</em> in much the same way as <em>winmain</em>, provide a metadata enriched implementation of <a href="http://www.gnu.org/software/hello/manual/libc/Getopt.html"><em>getopt</em></a>, <em>man</em>, etc. There is no need to invent a new shell in order to acquire the power of piping objects. Sure, cmd is old and needed to be retired for many other reasons, but it is a real shame that the PowerShell toolset is not available to those of us stuck in batch scripts.</p><p>Personally, I would really like to see such a library developed. Microsoft has certainly proved one thing with PowerShell: steep learning curves are not intrinsic to command line interfaces. Unfortunately, commandlets are two steps forward and one step backwards. I have no doubt that we can retake that forward step.</p><style type="text/css"><br />.code, .code pre<br />{<br />	font-size: small;<br />	color: black;<br />	font-family: consolas, "Courier New", courier, monospace;<br />	background-color: #ffffff;<br />	/*white-space: pre;*/<br />}<br />.code pre { margin: 0em; }<br /></style>    </div>
  <h2>Comments</h2>
  <div class='comments'>
    <div class='comment'>
      <div class='author'>klumsy</div>    <div class='content'>
    I find the 2nd point interesting given that most of the powershell team were unix only guys before this project.      </div>
    </div>
    <div class='comment'>
      <div class='author'>Brandon Bloom</div>    <div class='content'>
    I don't know the history of PowerShell or any of the team members. I'm sure they are all very smart and have a strong grasp of Unix in general. Maybe they understand exactly what I'm getting at, but explicitly rejected it for some non-obvious reasons (such as scheduling, implementation complexity, target users, etc). They probably know better than I do. My apologies for exaggerating to make a point :-)      </div>
    </div>
    <div class='comment'>
      <div class='author'>Howard T. Snidbiscuits</div>    <div class='content'>
    I agree, PowerShell is way better than the primitive, DOS style Windows CMD. However, it&#39;s nothing like a normal Unix shell for me... and I&#39;d rather just use cygwin.      </div>
    </div>
    <div class='comment'>
      <div class='author'>Kosta</div>    <div class='content'>
    Sorry but no: Pipelining objects is much smarter. You can still pipe strings or binary data if you want, but you don&#39;t have all the drawbacks.<br /><br />And then there&#39;s the security implications. While theoratically possible, are all your scripts safe against whitespace|&quot;&#39;` injection? Piping objects is sooo much easier AND it does not kill your system if the bytestream contains `rm -rf /`. <br /><br />Just my two cents...      </div>
    </div>
    <div class='comment'>
      <div class='author'>Powershell Jedi</div>    <div class='content'>
    Unix is optimized around flat files windows is optimized around objects. It&#39;s not the they don&#39;t understand Unix. The Powershell Team has a strong unix Background. It&#39;s just just that M$ has 87% market share and a trillion dollars in the bank share that says F@ck unix.      </div>
    </div>
    <div class='comment'>
      <div class='author'>Brandon Bloom</div>    <div class='content'>
    Piping objects has draw backs too. Here&#39;s a case that came up on the internal PowerShell mailing list...<br /><br />Unix:<br /><br />cat foo | wc -l<br /><br />PowerShell:<br /><br />Get-Content foo | Measure-Object -line<br /><br />Ignore the line length, as I didn&#39;t use any aliases for the PowerShell version. The issue here is that Get-Content returns a String, not a StreamReader. The result is that for large files, the entire String must be read into memory and for really large files, swapped back out to disk!<br /><br />You could easily work around this with objects; this example is just to show that objects have drawbacks just as byte streams do. Everything is always a balance. I like the Unix approach because it is a simple system with drawbacks that are well understood. I dislike the object approach because it is a complex system with less obvious drawbacks that don&#39;t bite you until much later.      </div>
    </div>
    <div class='comment'>
      <div class='author'>Len</div>    <div class='content'>
    Are you kidding?  MS couldn&#39;t even get the <i>simplest</i> thing right.  Their &quot;compare-object&quot; is supposed to be their &quot;equivalent&quot; to diff.  Not so.  Not even close.  Try comparing these two files:<br /><br />file 1:<br />a<br />b<br />c<br />d<br /><br />file 2:<br />d<br />c<br />b<br />a<br /><br /><br />Unix diff correctly shows how they are different.  MS compare-objects says they are the same.  Why?  Because the latter doesn&#39;t care about order.<br /><br />Microsoft is not &quot;very smart&quot;.  They are demented.      </div>
    </div>
</div>
